<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xmlns:xl="http://www.w3.org/1999/xlink">
    <info>
        <title>RSTModules</title>
        <subtitle>User's Guide</subtitle>
        <authorgroup>
            <author>
                <personname>
                    <firstname>Florian</firstname>
                    <surname>Zipser</surname>
                </personname>
                <email>saltnpepper@lists.hu-berlin.de</email>
            </author>
            <author>
                <personname>
                    <firstname>Mario</firstname>
                    <surname>Frank</surname>
                </personname>
                <email>saltnpepper@lists.hu-berlin.de</email>
            </author>
            <author>
                <orgname xml:id="org1">INRIA</orgname>
            </author>
            <author>
                <orgname xml:id="org2">SFB 632 Information Structure / D1 Linguistic
                    Database</orgname>
            </author>
            <author>
                <orgname xml:id="org3">Humboldt-Universität zu Berlin</orgname>
            </author>
            <author>
                <orgname xml:id="org4">Universität Potsdam</orgname>
            </author>
        </authorgroup>
        <copyright>
            <year>2009</year>
            <holder><xref linkend="org1"/>, <xref linkend="org2"/>, <xref linkend="org3"/>, <xref
                    linkend="org1"/>,<xref linkend="org4"/>, All rights reserved.</holder>
        </copyright>
        <releaseinfo>Version ${project.version}</releaseinfo>
    </info>
    <preface>
        <title>Foreword</title>
        <para>The intention of this document is first to give a guide to the user of how to use the
            here mentioned pepper modules and how to utilize a mapping performed by them. Second
            this document shall give a closer view in the details of such a mapping in a declarative
            way, to give the user a chance to understand how specific data will be mapped by the
            presented pepper modules.</para>
    </preface>
    <chapter>
        <title>Overview</title>
        <para>This project contains the pepper modules listed in <xref linkend="table_overview"/>. A
            single module can be identified via its coordinates (module-name, format-name,
            format-version) also given in <xref linkend="table_overview"/>. You can use these
            coordinates in a pepper workflow description file to identify the modules in a pepper
            conversion process. A description of how to model a workfloe description file can be
            found under https://korpling.german.hu-berlin.de/saltnpepper/.</para>
        <para>RST stands for  Rhetorical Structure Theory and descibes a linguistical analysis. Next
            to to the rethorical structure theory, a tool named RST Tool was developed see:
            <link xl:href="http://www.wagsoft.com/RSTTool/">http://www.wagsoft.com/RSTTool/</link>. 
            This tool produces rs3 files, which
            are imported by the here provided RSTImporter. The RSTImporter makes use of the rst-api
            (see: <link xl:href="https://korpling.german.hu-berlin.de/p/projects/rst-api/wiki">https://korpling.german.hu-berlin.de/p/projects/rst-api/wiki</link>). </para>
        <table xml:id="table_overview" frame="all">
            <title>pepper modules contained in this project</title>
            <tgroup cols="3" align="left" colsep="1" rowsep="1">
                <thead>
                    <row>
                        <entry>Name of pepper module</entry>
                        <entry>Type of pepper module</entry>
                        <entry>Format (if module is im- or exporter)</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry><xref linkend="rst_importer" endterm="rst_importer_name"/></entry>
                        <entry>importer</entry>
                        <entry>1.0</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </chapter>
    <!-- 
    <chapter xml:id="changes">
        <title>Changes</title>
        <para>No changes so far.</para>
    </chapter>
    -->
    <chapter xml:id="rst_importer">
        <title xml:id="rst_importer_name">rstImporter</title>
        <para>Rst is a theory on phrase-like constructs, which mean, that a token in rst is a
            phrase. When mapping these data to Salt, an SToken object represents such a phrase.
            Since in most cases this is not the wanted behaviour, the RSTImporter provides a
            mechanism to tokenize the phrases into word-like structures. Therefore it takes use of
            the tokenizer provided by Salt which copies the way of tokenization from the TreeTagger
            (see: <link xl:href="www.ims.uni-stuttgart.de/projekte/corplex/TreeTagger/"
                >www.ims.uni-stuttgart.de/projekte/corplex/TreeTagger/</link> ). </para>
        <para>Rst in general forms a tree-like structure, which is mapped as this to a Salt model.
            For more information on the Rst model which is used, please take a look to the rst-api,
            where the RSTImporter is based on (see: <link xl:href="https://korpling.german.hu-berlin.de/p/projects/rst-api/wiki">https://korpling.german.hu-berlin.de/p/projects/rst-api/wiki</link>).</para>
        <sect1>
            <title>Mapping to Salt</title>
            <para>In rst, the primary data is represented by the textual values contained by
                    <classname>Segment</classname> objects. The text of all
                    <classname>Segment</classname> objects is mapped the sText value of  exactly one
                    <classname>STextualDS</classname> object. The text of a
                    <classname>Segment</classname> object is concatenated to the sText prefixed by
                the blank seperator ' '. Imagine a text of segment1 'Is this example' and the text
                of segment2 'more complicated than it is supposed to be', than the sText value is
                'Is this example more complicated than it is supposed to be'. The separator can be
                user defined or set to '' (empty) by taking use of the property <xref linkend="prop_prop5" endterm="importer_prop5_title"
                />.</para>
            <para>A <classname>Segment</classname> object itself is mapped to
                    <classname>sStructure</classname>. As already mentioned, the RSTImporter
                provides the mechanism to tokenize a text in word-like tokens. Therefore, the text
                covered by a <classname>Segment</classname> object is tokenized to
                    <classname>SToken</classname> objects. These <classname>SToken</classname>
                objects than are be related to <classname>SStructure</classname> object representing
                the <classname>Segment</classname> object via a
                    <classname>SDominanceRelation</classname>. In case of a
                    <classname>Segment</classname> object covers the text 'Is this example', the
                tokenizer will create <classname>SToken</classname> objects covering the text 'Is',
                'this' and 'example'. The three tokens are dominated by one
                    <classname>SStructure</classname> object. To avoid the tokenization, take use of
                the property <xref linkend="prop_prop1" endterm="importer_prop1_title"
                />.</para>
            <para>Each <classname>Group</classname> object is also mapped to a
                    <classname>SStructure</classname> object. The tree-like structure given by
                    <classname>Group</classname> objects and <classname>Relation</classname> objects
                related to <classname>Group</classname> or <classname>Segment</classname> objects is
                mapped to <classname>SStructure</classname> objects related via
                    <classname>SDominanceRelation</classname> objects. Imagine a
                    <classname>Group</classname> object 'grp1', containing another
                    <classname>Group</classname> object 'grp2' and a <classname>Segment</classname>
                object 'seg1'. This will be mapped into a Salt model having three
                    <classname>SStructure</classname> objects 'struct1' for 'grp1', 'struct2' for
                'grp2' and 'struct3' for 'seg1'. Further, two
                    <classname>SDominanceRelation</classname> objects 'dom1' and 'dom2' are created
                with 'struct1 -dom1-> struct2' and 'struct1 -dom2-> struct3'.</para>
            <para>Since all <classname>Group</classname> and <classname>Segment</classname> objects
                are mapped to <classname>SStructure</classname> objects, we won't loose the
                information, what has been the source. Therefore, for the kind of the node 'group'
                or 'segment' a <classname>SAnnotation</classname> object is created and related to
                the <classname>SStructure</classname> object. The sName of this
                    <classname>SAnnotation</classname> object is set to 'kind'. To change the sName,
                take use of the property <xref linkend="prop_prop2" endterm="importer_prop2_title"
                />.</para>
            <para>Also for the type attribute of a <classname>Group</classname> or
                    <classname>Segment</classname> object  an <classname>SAnnotation</classname>
                object is created. Its sName is set to 'type'. To adopt the sName, take use of the
                property <xref linkend="prop_prop3" endterm="importer_prop3_title"
                /></para>
            <para>The name of a <classname>Relation</classname> object is mapped to a
                    <classname>SAnnotation</classname> object having the  sName 'name'. To avoid,
                that a bunch of <classname>Relation</classname> object get the same name, an
                artificial number is concatenated to the name
                    (<classname>SDominanceRelation.sName</classname>='name'+ occurance). For
                instance there are two <classname>Relation</classname> objects haveing the name
                'rel', than the first will get the sName 'rel1' and the second will get the sName
                'rel2'.</para>
            <para>The type of a <classname>Relation</classname> object ( //relations/rel@type in
                rs3) is mapped to the <classname>sType</classname> of a created
                    <classname>SDominanceRelation</classname> object. </para>
        </sect1>
        <sect1>
            <title>Properties</title>
            <para> The table <xref linkend="importer_prop_overview"/> contains an overview of all
                usable properties to customize the behaviour of this pepper module. The following
                section contains a close description to each single property and describes the
                resulting differences in the mapping to the salt model.</para>
            <table xml:id="importer_prop_overview" frame="all">
                <title>properties to customize importer behaviour</title>
                <tgroup cols="4" align="left" colsep="1" rowsep="1">
                    <thead>
                        <row>
                            <entry>Name of property</entry>
                            <entry>Type of property</entry>
                            <entry>optional/ mandatory</entry>
                            <entry>default value</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><xref linkend="prop_prop1" endterm="importer_prop1_title"
                                /></entry>
                            <entry>yes|no</entry>
                            <entry>optional</entry>
                            <entry>yes</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop2" endterm="importer_prop2_title"
                            /></entry>
                            <entry>String</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop3" endterm="importer_prop3_title"
                            /></entry>
                            <entry>String</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop4" endterm="importer_prop4_title"
                            /></entry>
                            <entry>String</entry>
                            <entry>optional</entry>
                            <entry>--</entry>
                        </row>
                        <row>
                            <entry><xref linkend="prop_prop5" endterm="importer_prop5_title"
                            /></entry>
                            <entry>String</entry>
                            <entry>optional</entry>
                            <entry>' ' (Blank)</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <sect2 xml:id="prop_prop1">
                <title xml:id="importer_prop1_title">rstImporter.tokenize</title>
                <para>This parameter is an optional parameter and can be set to “yes” or “no”. If it
                    is set to “yes”, the text being included in a segment will be tokenized. The
                    tokens will be mapped to <classname>SToken</classname>-objects in Salt and
                    attached to the <classname>SDocumentGraph</classname>-object. Further, an
                        <classname>STextualRelation</classname> between a token and the text will be
                    created and a dominance relation between the token and the segment. The default
                    configuration of this parameter is true, if non tokenization is required, this
                    parameter must explicitly set to false.</para>
            </sect2>
            <sect2 xml:id="prop_prop2">
                <title xml:id="importer_prop2_title">rstImporter.nodeKindName</title>
                <para>Name of the property to specify the sName of the SAnnotattion to which the kind of a node (segment or group) is mapped.</para>
            </sect2>
            <sect2 xml:id="prop_prop3">
                <title xml:id="importer_prop3_title">rstImporter.nodeTypeName</title>
                <para>Name of the property to specify the sName of the SAnnotation to which the type attribute of a node is mapped.</para>
            </sect2>
            <sect2 xml:id="prop_prop4">
                <title xml:id="importer_prop4_title">rstImporter.relationTypeName</title>
                <para>Name of the property to specify the sName of the SAnnotation to which the name attribute of a relation is mapped to.</para>
            </sect2>
            <sect2 xml:id="prop_prop5">
                <title xml:id="importer_prop5_title">rstImporter.relationTypeName</title>
                <para>A property to add a a separator like a blank between the text of segments, when it is concatenated to the primary text in STextualDS.For instance the segment text 'Is' of segment1 and the segment text 'this' of segment2 will be concatenated to an sText value 'is'SEPARATOR'this'.</para>
            </sect2>
        </sect1>
    </chapter>
</book>
